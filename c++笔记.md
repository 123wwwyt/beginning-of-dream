# 怎么边上课边记笔记？方法
先点开vs的全屏，然后分别把左右两边调到最小。注意，在小屏时是无法把两边都叉掉的。
# 不要写太长，可以一月一完结，不然电脑会卡的


# 目录：
1，指针

2.函数
## 12.8 c指针与数组

前提：不讲语法，只讲最本质的理解
语法要自己去看

## 指针回忆

### 1.符号理解

*有两层意义，
~~~
int *a;// 此时*代表  我声明了一个指针

& 是取地址运算符，获取变量的内存地址。
int a = 6;
printf("%d",&a); //会输出a 的地址

//注意：printf("%d",a);才会输入a的值6，不要搞混
~~~
~~~
int a = 6;
int *p;
p = &a;//指针p指向整型变量a 的地址。
printf("%d",*p);//此时*是解指针

总之：*在定义变量时是定义一个指针变量的意思，其余时候就是解指针的意思。
~~~

## 指针总结；（速览）
指针本质就是一个地址

内存地址只是一个十六进制的数字，表示内存区域，容量以字节为基本单位。

指针指向的本质：地址赋值

多重指针：间接寻址，指针链

指针变量除了可以存放变量的地址，还可以存放其他数据的地址，例如可以存放数组和函数的地址

## 数组概况
数组也是一种数据类型，但是是复合数据类型

里面储存什么就是什么数组，甚至还有指针数组

数组里面的内容只能连续存放

数组名是一个指向数组第一个元素的指针常量，也就是说，亚储存的是数组第一个元素的地址，并且不能被修改哦

数组名的两层含义：做数组名是代指整个数组（空间），做指针常量是，保存数组第一个元素的地址。
### 函数里面的运用
~~~
void swap(int *a,int *b)//相当于定义了指针，即输入的是指针
{
    int t = *a;// *解开；了指针，t获得了指针对应的值

    *a = *b;
    *b = t;
}
int main(){
    int a = 6;
    int b = 3;
    swap(&a,&b);//注意：指针变量对应地址，所以要取地址
    printf("%d %d",a,b);
}
~~~
数组也是指针；
~~~
数组是指针常量，不能修改。

int c[3] = {1,2,4};
printf("%d",*c)
会输出1；因为*c是解指针，只得到数组中第一个数
printf("%d",*(c+1))//+1代表指针的移位置

//得到公式 *(c+1) = c[1];
甚至对指针也是可以这样做：*(p+1)= p[1];

下面具体举例子：
~~~
int c[3]= {1,2,3};
int *p = *(c +1);
此时*(p+1) = p[1];

//感兴趣 也可以玩玩下面的这个
int c[3] = { 1,2,4 };
int* p = (c + 1);
printf("%d \n%d", p[-1], *(p + 1));

~~~
这也是为什么数组要从0开始数

并且，对指针的任何运算都是移位的作用
~~~

### 1 
指针就是标记数据的地址，可以有一级指针和二级指针。

### 2 计算机组成：冯诺依曼 架构
~~~
输入        存储器       输出
     运算器       控制器 
         （这两个叫 cpu,与控制器交互）
有数据流，指令流，控制流
~~~

存储器：分为内存和外存

所有数据最本质存在外存，

外存才是真正存放东西的地方（断电数据不丢失）

内存关机断电数据丢失（时里面是没有东西的。）

运行qq，其相关数据代码都要在内存运行，方式是copy,运行完再删去

外存比内存大得多。

内存条：拆机用，自己去网上搜

指令流：什么是指令？保存的数据都是以二进制的形式。代码也是二进制保存，即机器码。每个不可拆分的机器码，就是指令。

编写程序：高级语言
执行：机器语言

汇编语言；以助记符形式表示的机器指令。

总结：存储器；最重要，存储指令和数据

## 存储器容量：
1bit(位) 1 byte(1B)（字节）,1KB,1MB,

一个二进制位称为1bit.1B = 8b
即1B= 8bit.

之后的换算关系是2^10
1GB = 2^30B

## 如何从上亿的字节中找到特定的字节？8GB就很大了
以64位系统为例

所以出现了数据类型。
char 1B

int 4B

long long 8B

float 4B

double 8B

指针：8B 64bit   理论可以0~~2……64-1个编址，但实际取决于你的内存条。

一个特殊的数据类型：指针，是存放数据的内存单元地址

~~~
int a = 6;
int *p = &a;
~~~
## 为什么指针会是数据？内存的编址问题。
先确定编址单位。

大部分都是以字节为单位编址。

比如8位一个地址
………… ………… ………… …………

0    1     2   3

此时便可以存放一个int 

如何找到？只要找到0位就行（即找到首字节），后面按大小找就行

并且，因为地址是大于0的数，所以可以用指针这个变量来保存。

## 什么是指针？每个存储单元有唯一的地址
~~~
int a = 8;
int* p = &a;
printf("%p", p);
~~~
符号理解：& 叫做引用，可以叫做取地址符号，只找首字节的地址，就可以找到后面的。

%p  是输出十六进制的数字

“*” 为解引用----》取值符号

## 什么是变量名？
实际上，变量名 比如int a = 9;相当于定义了一段内存空间的名字，一个变量名对应了一个内存空间
## 变量名与指针的关系；
变量名定义了内存空间的名字，而指针标出了详细地址
清华大学（变量名）：北京市双清路（指针）

## 
~~~
int a = 8;
int *p = &a;
int c = *p;
printf("%p%d",p,c);
总共有三个内存空间，从而指向。
简单禅师；
先用变量a定义了一个内存空间的名字，然后又定义了指针p，这里面指向了a内存空间的地址(其实更像是把a内存空间的地址储存到了自己的内存空间里面)，之后，又定义了c内存空间，里面存放了（先是解开p指针指向的值，返回了p指针地址对应的值）（* 是取值，取出值）

最后的输出结果就是：指针p的地址，以及a的值，即8；

~~~
## 二级指针
只要是变量，就会对应一块内存空间，就有地址

操作系统负责分配内存空间

编址就是操作系统完成的

一级指针保存基础变量的地址
二级指针保存一级指针的地址
n级指针保存n-1级指针的地址
但都是八个字节；

注意：指针也是数据类型，也有地址
~~~

int a = 8;
int *p = &a;
int c = *p;
printf("%p%d",p,c);
int **q = &p;

~~~

## 指针总结；
指针本质就是一个地址

内存地址只是一个十六进制的数字，表示内存区域，容量以字节为基本单位。

指针指向的本质：地址赋值

多重指针：间接寻址，指针链

指针变量除了可以存放变量的地址，还可以存放其他数据的地址，例如可以存放数组和函数的地址

数组指针和函数指针

……
## 为什么要指针：
节省时间和内存，有助于数据共享

其次，指针无论类型，占用大小相等，8个字节

指针很灵活，可以将不连续的内存像数组一样连起来
### malloc
（返回内存空间的首地址，则一定是一个指针）malloc函数（尺寸），动态内存分配
例如：(int *)malloc(尺寸)

## 输入输出标准符
~~~
1．转换说明符
      %a(%A)     浮点数、十六进制数字和p-(P-)记数法(C99)
      %c             字符
      %d             有符号十进制整数
      %f              浮点数(包括float和doulbe)
      %e(%E)     浮点数指数输出[e-(E-)记数法]
      %g(%G)     浮点数不显无意义的零"0"
      %i              有符号十进制整数(与%d相同)
      %u             无符号十进制整数
      %o             八进制整数    e.g.     0123
      %x(%X)      十六进制整数<?xml:namespace prefix = st1 />()   e.g.   0x1234
      %p             16进制
      %s             字符串
      %%            "%"

2．标志
      左对齐："-"   e.g.   "%-20s"
      右对齐："+" e.g.   "%+20s"
      空格：若符号为正，则显示空格，负则显示"-"   e.g.   "% "      
      #：对c,s,d,u类无影响；对o类，在输出时加前缀o；对x类，在输出时加前缀0x；
           对e,g,f 类当结果有小数时才给出小数点。

3．格式字符串（格式）
      ［标志］［输出最少宽度］［．精度］［长度］类型 
     "％-md" ：左对齐，若m比实际少时，按实际输出。
     "%m.ns"：输出m位，取字符串(左起)n位，左补空格，当n>m or m省略时m=n
                      e.g.    "%7.2s"   输入CHINA
                                 　           输出"     CH"
     "%m.nf"：输出浮点数，m为宽度，n为小数点右边数位
                      e.g.    "%"    输入3852.99
                                               输出3853.0 
      长度：为ｈ短整形量,ｌ为长整形量

printf的格式控制的完整格式：
% - .n l或h 格式字符
下面对组成格式说明的各项加以说明：
①%：表示格式说明的起始符号，不可缺少。
②-：有-表示左对齐输出，如省略表示右对齐输出。
③0：有0表示指定空位填0,如省略表示指定空位不填。
④m.n：m指域宽，即对应的输出项在输出设备上所占的字符数。N指精度。用于说明输出的实型数的小数位数。为指定n时，隐含的精度为n=6位。
⑤l或h:l对整型指long型，对实型指double型。h用于将整型的格式字符修正为short型。

~~~

## 数组（指针与数组的结合）

### 概况
数组也是一种数据类型，但是是复合数据类型

里面储存什么就是什么数组，甚至还有指针数组

数组里面的内容只能连续存放

数组名是一个指向数组第一个元素的指针常量，也就是说，亚储存的是数组第一个元素的地址，并且不能被修改哦

数组名的两层含义：做数组名是代指整个数组（空间），做指针常量是，保存数组第一个元素的地址。

### 数组指针和指针数组

符号的优先级：[]优先级> *
#### 数组指针：数组的指针,指向数组空间的指针。
~~~
int (*p)[5]
~~~
#### 指针数组：指针的数组：
~~~
int *p[5]
~~~
#### 代码展示
~~~
int a[5]= {2,6,4,7,8};
int (*p)[5];
p = &a;
printf("%p %p %p %d",p,a,*p,*a);
前三个输出的相同，

第一个输出：整个数组数据的地址就是a[0]的地址，与第二的含义不同

第二个：a的地址就是a[0]的地址

第三个（这个是特例）：*p试图取出数据，但不知道取出什么数据，所以只能输出地址

第四个：变量名保存的是第一个元素的地址，对其取值，就得到了2；

int *q[5] 
q[0] = &a[0];
q[1] = &a[2];  ///不要求顺序
     
 注意：这里按照字节编址，所以a[2] 的 地址比a[1]多4

return 0;
~~~

#### 来了。公式化理解
~~~
int *q = &a[0];
printf("%n",q+1);
对指针加一，则地址加的的实际值为指针对应的数据类型所占的字节长度，比如上面这个是int类型，地址会加4

同理：int (*p)[5];
printf("%p",p+1);
地址会加二十，因为这个数组的指针所对应大小是4*5；
~~~

### 一些误区
####
输出数据与输出标准符号没有关系，只是代表输出的格式是什么

int a[5]= {2,6,4,7,8};
int (*p)[5];
p = &a;
printf("%p %p %d %d",p,a,*p,*a);
还是可以输出的
，只不过从原来的16进制输出变成10进制输出了，但还是输出了地址